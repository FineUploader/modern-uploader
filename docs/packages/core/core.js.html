<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import deliverEvent from './event-handler'
import loadPlugins from './plugin-loader'
import Plugin from './plugin'

const listeners = new WeakMap()

/**
 * Main class for core plug-in.
 *
 * @extends Plugin
 * @since 0.0.0
 * @example
 * import Core from 'core'
 *
 * const modernUploader = new Core([
 *    new SomePlugin1(),
 *    new SomePlugin2()
 * ])
 */
class Core extends Plugin {
    /**
     * Loads an array of plug-ins.
     *
     * @param {Array} plugins - Plugin object instances.
     * @throws {Error} If one of the passed plug-ins does not extend Plugin or if no plug-ins are passed.
     * @since 0.0.0
     */
    constructor(plugins = []) {
        super('core')
        listeners.set(this, {})
        loadPlugins(plugins, this)
    }

    /**
     * Trigger an event to be passed to all other registered event listeners. This event will be
     * bubbled, starting with the first registered listener, and ending with the last.
     *
     * @param {Event} event event to pass to all registered listeners for this event type.
     * @returns {Promise} Once the event has been bubbled to all registered listeners,
     * the result will be returned by resolving or rejecting this returned Promise, depending on the outcome.
     * If the event is cancelled by a listener, this Promise will be rejected with any data provided
     * by the cancelling listener. If this event is not cancelled, any data provided by all listeners
     * will be included when resolving the returned Promise.
     * @since 0.0.0
     * @example
     * // A plug-in that wants to add a new item (File/Blob/etc),
     * // will fire an "add" event, which will be handled by the
     * // core plug-in, resulting in the addition of the item
     * // to the internal cache maintained by the core plug-in.
     * // But some other plug-in could also prevent this add
     * // from happening before it reaches the core plug-in
     * // (perhaps a validator plug-in, for example).
     * core.fire(
     *    new Event({
     *       type: 'add',
     *       payload: {
     *          item: someFile
     *       }
     *    })
     * )
     * .then(
     *    function added(event) {
     *       // the item was added
     *    },
     *
     *    function notAdded(event) {
     *       // something prevented item from being added
     *    }
     * )
     */
    fire(event) {
        const myListeners = listeners.get(this)
        return deliverEvent(event, myListeners)
    }

    /**
     * Register one or more handlers for one or more specific events.
     *
     * @param {(string|Object)} typeOrListenersObject Register one listener by specifying the event type as a string here,
     * followed by the listener function as the next parameter, or pass a single object parameter
     * with event type properties and listener function values to conveniently register for multiple events.
     * @param {eventCallback} Listener Function to be called when the passed event type is fired.
     * This parameter is ignored if the first parameter is a listener object. In that case, it must be
     * supplied as the value for each event type property in the passed object.
     * @since 0.0.0
     * @example
     * // register a single listener for an "add" event
     * core.on('add', event => {
     *    // handle "add" event
     * })
     *
     * // register a listener for the "add" event,
     * // and another for the "remove" event
     * core.on({
     *    add: event => {
     *       // handle "add" event
     *    },
     *    remove: event => {
     *       // handle "remove" event
     *    }
     * })
     */
    on(typeOrListenersObject, listener) {
        if (typeof typeOrListenersObject === 'string') {
            const type = typeOrListenersObject
            const myListeners = listeners.get(this)
            const typeListeners = myListeners[type] || []

            typeListeners.push(listener)
            myListeners[type] = typeListeners
            listeners.set(this, myListeners)
        }
        else {
            Object.keys(typeOrListenersObject).forEach(type => {
                this.on(type, typeOrListenersObject[type])
            })
        }
    }

    /**
     * Register a listener for all events. This may be useful for plug-ins that need to be notified
     * whenever any event is triggered in the system. A good example would be a plug-in that logs all
     * activity.
     *
     * @param {eventCallback} listener Listener function
     * @since 0.0.0
     * @example
     * // register for all system events
     * core.onAll(event => {
     *    console.log(`I just received an event of type ${event.type}.`)
     *    // do something else with this event:
     *    //   - return a new value for the originator
     *    //   - cancel the event
     *    //   - passively listen or react in some other way
     * })
     */
    onAll(listener) {
        const myListeners = listeners.get(this)
        Object.keys(myListeners).concat('*').forEach(type => this.on(type, listener))
    }

    /**
     * Invoked when notifying a handler about an event it has registered for.
     *
     * @callback eventCallback
     * @param {Event} Event object assocaited with the registered event.
     */
}

export default Core
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Core.html">Core</a></li><li><a href="Event.html">Event</a></li><li><a href="Plugin.html">Plugin</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Apr 04 2016 21:04:39 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
